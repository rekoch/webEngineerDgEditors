<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>‚ù§Ô∏è‚Äçü©π like Funktion wiederherstellen - Learn To Build A Web Page</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn To Build A Web Page</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="-like-funktion-wiederherstellen"><a class="header" href="#-like-funktion-wiederherstellen">‚ù§Ô∏è‚Äçü©π Like-Funktion wiederherstellen</a></h1>
<h2 id="-√úberblick"><a class="header" href="#-√úberblick">üéØ √úberblick</a></h2>
<p>Mit <a href="./backendConnect.html">connect the backend</a> hast du daf√ºr gesorgt, dass Like-Counter-Daten aus dem Backend stammen. Der Button selbst funktioniert aber noch nicht korrekt. Wir implementieren die Like-Verwaltung in zwei Schritten:</p>
<h3 id="ziele"><a class="header" href="#ziele">Ziele:</a></h3>
<ol>
<li><strong>Blog-Page liken</strong> - mit korrekter UI und Backend-Verbindung</li>
<li><strong>Blog-Page entliken</strong> - mit korrekter UI und Backend-Verbindung</li>
<li><strong>User-ID-Wechsel</strong> - korrekte Reaktion auf Benutzer-√Ñnderungen</li>
</ol>
<hr />
<h2 id="like--dislike-implementation"><a class="header" href="#like--dislike-implementation">Like &amp; Dislike Implementation</a></h2>
<h3 id="toggle-logik-verstehen"><a class="header" href="#toggle-logik-verstehen">Toggle-Logik verstehen</a></h3>
<p>Like und Dislike sind sehr √§hnlich - wir <strong>togglen</strong> zwischen den Zust√§nden:</p>
<ol>
<li><strong>Aktuellen Zustand abfragen</strong> (geliked oder nicht?)</li>
<li><strong>Zustand umkehren</strong> (like ‚Üí unlike, unlike ‚Üí like)</li>
<li><strong>UI entsprechend aktualisieren</strong></li>
</ol>
<h3 id="architektur-entscheidung"><a class="header" href="#architektur-entscheidung">Architektur-Entscheidung</a></h3>
<p>Das File <code>likeStateHandler.js</code> soll erneut die Haupt Verantwortung daf√ºr √ºbernehmen. Wir haben auch ein File <code>button.js</code>. Dies soll einzig und alleine feststellen, dass der Button gedr√ºckt wurde und danach alles weitere dem <code>likeStateHandler.js</code> √ºberlassen.</p>
<p><strong>File-Aufgabenverteilung:</strong></p>
<ul>
<li><code>buttons.js</code> - <strong>Nur</strong> Button-Klick erkennen und Event versenden</li>
<li><code>likeStateHandler.js</code> - <strong>Komplette</strong> Like-Logik verwalten</li>
</ul>
<p>Um so eine Aufgabe zu delegieren, gibt es grunds√§tzlich verschiedene M√∂glichkeiten.</p>
<ol>
<li>Wir stellen eine Funktion bereit √ºber "export" die danach von anderen direkt genutzt werden kann</li>
<li>Wir versenden einen Event und k√ºmmern uns nicht darum, welches File sich der Aufgabe animmt.</li>
</ol>
<p>Da wir bereits ein Event System zur Verf√ºgung haben, setzen wir Variante 2 um. Diese l√§sst mehr Spielraum zu.</p>
<p><strong>Event-basierte Kommunikation:</strong></p>
<ul>
<li>‚ùå Option 1: Direkte Funktionsaufrufe (enger gekoppelt)</li>
<li>‚úÖ <strong>Option 2</strong>: Event versenden (flexibler, entkoppelter)</li>
</ul>
<hr />
<h2 id="like-event-versenden"><a class="header" href="#like-event-versenden">Like Event versenden</a></h2>
<p>Im <code>button.js</code> File √ºberwachen wir bereits, ob ein Button geklickt wird. Was uns dort noch fehlt ist der Versand unseres Events, damit wir danach im <code>likeStateHandler.js</code> darauf reagieren k√∂nnen.</p>
<h3 id="buttonjs-erweitern"><a class="header" href="#buttonjs-erweitern">Button.js erweitern</a></h3>
<p><strong>Observer und Events importieren:</strong></p>
<pre><code class="language-javascript">import { appObserver, ObserverEvents } from "../../services/observer.js";
</code></pre>
<p><strong>Event bei Button-Klick versenden:</strong></p>
<pre><code class="language-javascript">document.querySelectorAll("button[data-button]").forEach((button) =&gt; {
  button.addEventListener("click", () =&gt; {
    switch (button.dataset.button) {
      case "like_article":
        appObserver.emit(ObserverEvents.LIKE_BUTTON_CLICKED);
        break;
      // ... andere Cases
    }
  });
});
</code></pre>
<h3 id="-test-der-event-√úbertragung"><a class="header" href="#-test-der-event-√úbertragung">‚úÖ Test der Event-√úbertragung</a></h3>
<ol>
<li><strong>Seite mit LiveServer starten</strong></li>
<li><strong>Like Button klicken</strong></li>
<li><strong>Console beobachten</strong> - Zahlen-Output sollte sich erh√∂hen</li>
</ol>
<blockquote>
<p>üéâ <strong>Erfolg</strong>: LikeStateHandler empf√§ngt und verarbeitet dein Event!</p>
</blockquote>
<hr />
<h2 id="like-event-verarbeiten"><a class="header" href="#like-event-verarbeiten">Like Event verarbeiten</a></h2>
<p>Du siehst im Console.log wo der Event bereits empfangen wird. Im <code>likeStateHandler.js</code> um Zeile 70 rum. Jetzt m√ºssen wir noch die Logik erweitern, damit es auch das macht, was wir uns erhoffen. N√§mlich von dislike auf like und zur√ºck √§ndern, je nach aktuellem Zustand.</p>
<p>Gehe zur function <code>observeLikeEvents()</code> und ersetze die zuvor implementiere Code Stelle durch den Aufruf einer neuen Funktion die wir <code>toggleLikeState()</code> nennen und im Observer aufrufen.</p>
<h3 id="toggle-state-funktion-erstellen"><a class="header" href="#toggle-state-funktion-erstellen">Toggle-State-Funktion erstellen</a></h3>
<p><strong>Observer-Funktion erweitern:</strong></p>
<pre><code class="language-javascript">function observeLikeEvents() {
  appObserver.subscribe(ObserverEvents.LIKE_BUTTON_CLICKED, async () =&gt; {
    toggleLikeState();
  });
}

async function toggleLikeState() {
  // Logik kommt hier rein
}
</code></pre>
<h3 id="aktuellen-like-status-abfragen"><a class="header" href="#aktuellen-like-status-abfragen">Aktuellen Like-Status abfragen</a></h3>
<p>Damit wir nun wissen, was wir tun m√ºssen, brauchen wir den aktuellen Zustand des Likes (hat die Userin die Page geliked oder nicht)? Wir machen so was √§hnliches schon im <code>observeBlogPageIdChange</code> bzw. im <code>setLikeCounter</code>. Als erstes holen wir uns den Zustand aus dem Backend. Denke daran, dass wir wieder alles asynchron haben. Erweitere die Funktion wo n√∂tig mit <code>async</code></p>
<p><strong>Import der ben√∂tigten Services:</strong></p>
<pre><code class="language-javascript">import {
  getLikesPerBlogPage,
  getIsLikingBlogPage,
  likeBlogPage,
  unlikeBlogPage,
} from "../../services/blogPageLikes.js";
</code></pre>
<p><strong>Like-Status f√ºr User abfragen:</strong></p>
<pre><code class="language-javascript">async function toggleLikeState() {
  const doesUserLikeBlogPageResponse = await getIsLikingBlogPage(
    blogPageId,
    currentUserId
  );

  if (doesUserLikeBlogPageResponse.liked) {
    // User hat bereits geliked ‚Üí Unlike
  } else {
    // User hat noch nicht geliked ‚Üí Like
  }
}
</code></pre>
<h3 id="backend-status-√§ndern"><a class="header" href="#backend-status-√§ndern">Backend-Status √§ndern</a></h3>
<p>Jetzt k√∂nnen wir direkt dem Backend mitteilen, dass sich der Zustand ge√§ndert hat.</p>
<pre><code class="language-javascript">async function toggleLikeState() {
  const doesUserLikeBlogPageResponse = await getIsLikingBlogPage(
    blogPageId,
    currentUserId
  );

  if (doesUserLikeBlogPageResponse.liked) {
    await unlikeBlogPage(blogPageId, currentUserId);
  } else {
    await likeBlogPage(blogPageId, currentUserId);
  }
}
</code></pre>
<hr />
<h2 id="ui-updates-implementieren"><a class="header" href="#ui-updates-implementieren">UI-Updates implementieren</a></h2>
<p>Das UI braucht noch etwas mehr, damit es jeweils korrekt ist.</p>
<h3 id="button-ui-update-funktion"><a class="header" href="#button-ui-update-funktion">Button-UI-Update-Funktion</a></h3>
<pre><code class="language-javascript">function updateLikeButtonUi(isLiked) {
  const likeButton = document.querySelector(
    "button[data-button='like_article']"
  );

  if (isLiked) {
    likeButton.classList.remove("primary");
    likeButton.innerHTML = unlikePageText;
    likeButton.prepend(brokenHeart.cloneNode(true));
  } else {
    likeButton.classList.add("primary");
    likeButton.innerHTML = likePageText;
    likeButton.prepend(filledHeart.cloneNode(true));
  }
}
</code></pre>
<h4 id="erkl√§rungen"><a class="header" href="#erkl√§rungen">Erkl√§rungen</a></h4>
<ul>
<li>damit die Funktion weiss, was zu tun ist, nimmt sie ein Boolean Argument <code>isLiked</code>entgegen</li>
<li>basierend auf dem Wert, wird entweder der like oder der dislike Zustand angeschrieben</li>
<li>die Texte sind bereits als <code>const</code>im File vorhanden</li>
<li>die CSS Klasse <code>primary</code> muss entfernt oder hinzugef√ºgt werden</li>
</ul>
<h3 id="toggle-funktion-komplettieren"><a class="header" href="#toggle-funktion-komplettieren">Toggle-Funktion komplettieren</a></h3>
<p>Zuletzt passe den Aufruf im <code>toggleLikeState()</code>an. Am Schluss erg√§nze den <code>setLikeCounter()</code> Aufruf, der unabh√§ngig des Zustands genutzt werden kann.</p>
<pre><code class="language-javascript">async function toggleLikeState() {
  const doesUserLikeBlogPageResponse = await getIsLikingBlogPage(
    blogPageId,
    currentUserId
  );

  if (doesUserLikeBlogPageResponse.liked) {
    await unlikeBlogPage(blogPageId, currentUserId);
    updateLikeButtonUi(false);
  } else {
    await likeBlogPage(blogPageId, currentUserId);
    updateLikeButtonUi(true);
  }

  setLikeCounter(); // Counter aktualisieren
}
</code></pre>
<h3 id="-funktionstest"><a class="header" href="#-funktionstest">‚úÖ Funktionstest</a></h3>
<p><strong>Backend und Frontend starten</strong> und Like-Button testen!</p>
<hr />
<h2 id="error-handling-implementieren"><a class="header" href="#error-handling-implementieren">Error Handling implementieren</a></h2>
<p>Obwohl der Code funktioniert, k√∂nnten Fehler im Backend dazu f√ºhren, dass wir nicht sauber darauf reagieren. Ein try-catch um die potentiell problematischen Stellen hilft uns hier. Zudem wollen wir sicher gehen, dass wir mit <code>.liked</code> nicht auf ein allf√§llig nicht vorhandenes Objekt zugreifen.</p>
<p>Daf√ºr umschliessen wir den ganzen Code oben mit einem try und fangen Errors im Catch und geben sie in der Console aus.</p>
<h3 id="try-catch-f√ºr-robustheit"><a class="header" href="#try-catch-f√ºr-robustheit">Try-Catch f√ºr Robustheit</a></h3>
<pre><code class="language-javascript">async function toggleLikeState() {
  try {
    const doesUserLikeBlogPageResponse = await getIsLikingBlogPage(
      blogPageId,
      currentUserId
    );

    if (doesUserLikeBlogPageResponse.liked) {
      await unlikeBlogPage(blogPageId, currentUserId);
      updateLikeButtonUi(false);
    } else {
      await likeBlogPage(blogPageId, currentUserId);
      updateLikeButtonUi(true);
    }

    setLikeCounter();
  } catch (error) {
    console.error("Error toggling like state:", error);
  }
}
</code></pre>
<h3 id="pr√ºfen-auf-undefined"><a class="header" href="#pr√ºfen-auf-undefined">pr√ºfen auf undefined</a></h3>
<p>F√ºr den Fall, dass die response komplett leer / undefined ist, machen wir nichts. Nutzen wir den ? Operator bspw. <code>if (doesUserLikeBlogPageResponse.?liked)</code> w√ºrde das technisch funktionieren und keinen Fehler mehr geben. In Kombination mit einem if hat es aber zur Folge, dass sowohl bei (nicht vorhanden) wie auch (not liked) ein false ergibt und unsere Logik damit unsauber w√§re. Wir pr√ºfen also separat ob es vorhanden ist und stoppen alle weiteren Arbeiten, falls nicht. Das kannst du direkt nach dem abwarten der response machen.</p>
<pre><code class="language-javascript">async function toggleLikeState() {
  try {
    const doesUserLikeBlogPageResponse = await getIsLikingBlogPage(
      blogPageId,
      currentUserId
    );

    if (!doesUserLikeBlogPageResponse) {
      return; // Keine Response erhalten
    }

    if (doesUserLikeBlogPageResponse.liked) {
      await unlikeBlogPage(blogPageId, currentUserId);
      updateLikeButtonUi(false);
    } else {
      await likeBlogPage(blogPageId, currentUserId);
      updateLikeButtonUi(true);
    }

    setLikeCounter();
  } catch (error) {
    console.error("Error toggling like state:", error);
  }
}
</code></pre>
<hr />
<h2 id="user-id-wechsel-handhaben"><a class="header" href="#user-id-wechsel-handhaben">User-ID-Wechsel handhaben</a></h2>
<p>Aktuell ber√ºcksichtigt die Logik nur eine statische UserId aus dem <code>likeStateHandler.js</code>, die mit 0 gesetzt ist. Ein Wechsel der UserId wird nicht ber√ºcksichtigt. Zudem ist der initiale Stand beim Laden der Page potentiell falsch, da dies noch nicht korrekt geladen wird.</p>
<h3 id="user-change-observer-erweitern"><a class="header" href="#user-change-observer-erweitern">User-Change Observer erweitern</a></h3>
<p><strong>Bestehende Observer-Funktion finden:</strong></p>
<pre><code class="language-javascript">function observeUserIdChange() {
  appObserver.subscribe(
    ObserverEvents.USER_ID_CHANGED,
    async (data) =&gt; {
      currentUserId = data.userId;
      console.log("Current User ID in likeStateHandler:", currentUserId);
      // Hier Like-Status f√ºr neuen User laden
    },
    true // Replay-Funktion f√ºr Initial-State
  );
}
</code></pre>
<h3 id="like-status-check-funktion-erstellen"><a class="header" href="#like-status-check-funktion-erstellen">Like-Status-Check-Funktion erstellen</a></h3>
<p>Auch hier ist es √§hnlich wie mit der Blog Page Id. Die UserId wird initial schon im <code>main.js</code> gesetzt. Weil das Abo mit "true" am schluss auch Daten erh√§lt, wenn es erst nachtr√§glich das Abo bezieht, kriegen wir ganz sicher auch einen Initial-State und k√∂nnen darauf reagieren.</p>
<p>Jetzt m√ºssen wir im Prinzip nur herausfinden, welches der aktuelle State ist und das UI entsprechend korrekt darstellen.</p>
<p>Diesen Teil aus der vorherigen Methode macht genau das was wir erneut brauchen:</p>
<pre><code class="language-javascript">const doesUserLikeBlogPageResponse = await getIsLikingBlogPage(
  blogPageId,
  currentUserId
);
if (!doesUserLikeBlogPageResponse) {
  return;
}
</code></pre>
<p>Wie so oft‚Ä¶ wenn es nach "ich kann das nochmals brauchen" klingt, dann schreit es danach, die Funktionalit√§t in eine separate Funktion auszulagern.</p>
<p><strong>Wiederverwendbare Status-Check-Funktion:</strong></p>
<p>Damit wir "von aussen" wissen, ob es einen Fehler gab oder ob die Antwort "true / false" ist, m√ºssen wir unsere neue Funktion etwas smarter gestalten. Da wir im JavaScript ohne weiteres und jederzeit ein Objekt erstellen k√∂nnen, machen wir genau das. Wir erweitern die Antwort der Funktion um:
<code>{success: boolean, liked: boolean, error: string}</code></p>
<p>Als erstes nutzen wir das, wenn die "response" undefined / null ist. Dann hat irgendwie was nicht geklappt und wir k√∂nnen nicht sagen, ob eine Userin die Page liked oder nicht.</p>
<pre><code class="language-javascript">async function checkUserLikeStatus() {
  try {
    const response = await getIsLikingBlogPage(blogPageId, currentUserId);

    if (response === undefined || response === null) {
      return { success: false, liked: false, error: "No response received" };
    }
  } catch (error) {
    return { success: false, liked: false, error: error.message };
  }
}
</code></pre>
<p>Mit return <code>{}</code> erstellen wir ein Objekt, f√ºllen es mit den Properties ab und geben dies zur√ºck. Das ist das coole an JavaScript. Kein "boilerplate" n√∂tig wo wir zuerst mal den definieren m√ºssen, wie das Objekt aussieht. Auf der anderen Seite haben wir auf der "aufrufenden" Seite keine Ahnung, was wir eigentlich als Antwort kriegen‚Ä¶</p>
<p>Das selbe gilt wenn wir in den "catch" laufen. Wir wissen es hat was nicht geklappt und k√∂nnen die Antwort aus dem error direkt weitergeben.</p>
<pre><code class="language-javascript">async function checkUserLikeStatus() {
  try {
    const response = await getIsLikingBlogPage(blogPageId, currentUserId);

    if (response === undefined || response === null) {
      return { success: false, liked: false, error: "No response received" };
    }

  } catch (error) {
    return { success: false, liked: false, error: error.message };
  }
}
</code></pre>
<p>Wenn es weder "catch" noch undefined / null gewesen ist, hat es wohl funktioniert. Also geben wir ein <code>sucess:true</code>, den like state aus der response sowie keine Fehlermeldung == null zur√ºck.</p>
<pre><code class="language-javascript">async function checkUserLikeStatus() {
  try {
    const response = await getIsLikingBlogPage(blogPageId, currentUserId);

    if (response === undefined || response === null) {
      return { success: false, liked: false, error: "No response received" };
    }

    return { success: true, liked: response.liked, error: null };

  } catch (error) {
    return { success: false, liked: false, error: error.message };
  }
}
</code></pre>
<h3 id="toggle-funktion-refactoren"><a class="header" href="#toggle-funktion-refactoren">Toggle-Funktion refactoren</a></h3>
<p><strong>Status-Check-Funktion verwenden:</strong></p>
<pre><code class="language-javascript">async function toggleLikeState() {
  try {
    const likeStatus = await checkUserLikeStatus();

    if (!likeStatus.success) {
      console.error("Could not determine like status:", likeStatus.error);
      return;
    }

    if (likeStatus.liked) {
      await unlikeBlogPage(blogPageId, currentUserId);
      updateLikeButtonUi(false);
    } else {
      await likeBlogPage(blogPageId, currentUserId);
      updateLikeButtonUi(true);
    }

    setLikeCounter();
  } catch (error) {
    console.error("Error toggling like state:", error);
  }
}
</code></pre>
<h4 id="erkl√§rungen-1"><a class="header" href="#erkl√§rungen-1">Erkl√§rungen</a></h4>
<ul>
<li>wir nutzen neu den <code>likeStatus</code>um zu wissen, ob wir abbrechen oder nicht</li>
<li>mit dem <code>.</code>kannst du auf die Properties eines Objekts zugreifen. Hier f√ºr den status <code>likeStatus.success</code>, den like zustand <code>likeStatus.liked</code> und fehlermeldung <code>likeStatus.error</code></li>
</ul>
<h3 id="like-state-updaten-und-initialiseren"><a class="header" href="#like-state-updaten-und-initialiseren">Like State updaten und initialiseren</a></h3>
<p>Jetzt haben wir die Basis erarbeitet, um die Logik in unserer Changed User ID Logik wieder zu verwenden. Gehe zur Funktion <code>observeUserIdChange()</code> wo wir nun als erstes unsere neue Funktion <code>checkUserLikeStatus</code> aufrufen und analog zu vorher weiter verarbeiten.</p>
<pre><code class="language-javascript">const likeStatus = await checkUserLikeStatus();
</code></pre>
<p>Wenn der Status success ist, k√∂nnen wir direkt das UI updaten und wenn nicht, machen wir nichts bzw. k√∂nnen noch eine Meldung in der Console ausgeben. Zudem rufe noch die <code>setLikeCounter</code> auf. Damit haben wir bereits alles gemacht, um bei einem change der userID alles korrekt zu machen. Starte alles inklusive Backend und teste etwas. Du kannst nun oben rechts die userID anpassen und schauen was passiert.</p>
<p>Dein Code im <code>observeUserIdChange()</code> sollte ungef√§hr so aussehen.</p>
<pre><code class="language-javascript">function observeUserIdChange() {
  appObserver.subscribe(
    ObserverEvents.USER_ID_CHANGED,
    async (data) =&gt; {
      currentUserId = data.userId;
      const likeStatus = await checkUserLikeStatus();
      if (likeStatus.success) {
        updateLikeButtonUi(likeStatus.liked);
        setLikeCounter();
      } else {
        console.error("Could not fetch like status:", likeStatus.error);
      }
    },
    true
  );
}
</code></pre>
<p>Was noch fehlt ist das selbe, wenn die blog page id √§ndert. Dies ist in unserem Fall eigentlich nicht m√∂glich, aber wir wollen den Init √ºber das Main.js nutzen, wo die Blog Page ID gesetzt wird. So ist beim Laden sichergestellt, dass der Like State stimmt.</p>
<p>Erg√§nze daher auch die Funktion <code>observeBlogPageIdChange()</code> mit dem Setzen des likeStatus und des counters.</p>
<blockquote>
<p>üí° Dir f√§llt sicher auf, dass wir wiederum Code in zwei Methoden haben, der deckungsgleich ist. Das Laden des States und das Setzen.</p>
</blockquote>
<p><strong>DRY-Prinzip - Wiederverwendbare Init-Funktion:</strong></p>
<p>Don't repeat yourself. Legen wir dies so zusammen, dass wir es wieder verwenden k√∂nnen. Mittels einer neuen Funktion <code>initLikeState()</code> fassen wir die gemeinsame Logik zusammen und nutzen danach diese.</p>
<pre><code class="language-javascript">async function initLikeState() {
  const likeStatus = await checkUserLikeStatus();

  if (likeStatus.success) {
    updateLikeButtonUi(likeStatus.liked);
    setLikeCounter();
  } else {
    console.error("Could not fetch like status:", likeStatus.error);
  }
}
</code></pre>
<h3 id="observer-funktionen-finalisieren"><a class="header" href="#observer-funktionen-finalisieren">Observer-Funktionen finalisieren</a></h3>
<p><strong>User-ID-Change Observer:</strong></p>
<pre><code class="language-javascript">function observeUserIdChange() {
  appObserver.subscribe(
    ObserverEvents.USER_ID_CHANGED,
    async (data) =&gt; {
      currentUserId = data.userId;
      await initLikeState();
    },
    true
  );
}
</code></pre>
<p><strong>Blog-Page-ID-Change Observer:</strong></p>
<pre><code class="language-javascript">function observeBlogPageIdChange() {
  appObserver.subscribe(
    ObserverEvents.BLOG_PAGE_ID_CHANGED,
    async (data) =&gt; {
      blogPageId = data.blogPageId;
      await initLikeState();
    },
    true
  );
}
</code></pre>
<hr />
<h2 id="-endergebnis"><a class="header" href="#-endergebnis">üéâ Endergebnis</a></h2>
<h3 id="-implementierte-features"><a class="header" href="#-implementierte-features">‚úÖ Implementierte Features</a></h3>
<ol>
<li><strong>Like/Unlike Toggle</strong> - Backend-synchronisiert</li>
<li><strong>UI-Updates</strong> - Button-Text und Icon-√Ñnderungen</li>
<li><strong>Counter-Updates</strong> - Automatische Z√§hler-Aktualisierung</li>
<li><strong>User-Switching</strong> - Korrekte Like-Status-Anzeige pro User</li>
<li><strong>Error Handling</strong> - Robuste Fehlerbehandlung</li>
<li><strong>DRY Code</strong> - Wiederverwendbare Funktionen</li>
</ol>
<h3 id="vollst√§ndiger-test"><a class="header" href="#vollst√§ndiger-test">Vollst√§ndiger Test</a></h3>
<p><strong>Test-Szenarios:</strong></p>
<ol>
<li>‚úÖ Like/Unlike mit verschiedenen Users</li>
<li>‚úÖ User-ID-Wechsel oben rechts</li>
<li>‚úÖ Backend-Verbindung aktiv</li>
<li>‚úÖ Counter-Updates in Echtzeit</li>
</ol>
<p><strong>Die Like-Funktionalit√§t ist jetzt vollst√§ndig implementiert!</strong> üöÄ</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../javascript/blogPageIntelligence/backendConnect.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../javascript/blogPageIntelligence/follow.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../javascript/blogPageIntelligence/backendConnect.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../javascript/blogPageIntelligence/follow.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
